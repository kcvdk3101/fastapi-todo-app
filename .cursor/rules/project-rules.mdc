---
alwaysApply: true
---

# FastAPI Todo App - Project Rules

## Architecture & Structure

### Project Organization
- Follow the established layered architecture: `app/models/`, `app/schemas/`, `app/services/`, `app/routers/`, `app/core/`
- Keep business logic in `services/` layer, not in routers
- Use `schemas/` for Pydantic models (request/response validation)
- Use `models/` for SQLAlchemy database models
- Keep core configuration and utilities in `core/`
- Place route handlers in `routers/` with clear naming

### Database & Models
- Use Alembic for all database migrations
- Follow SQLAlchemy 2.0+ patterns with async/await
- Use PostgreSQL as the primary database
- All foreign key relationships must be properly defined with cascade rules
- Always include `created_at` and `updated_at` timestamps on models
- Use UUID primary keys for sensitive models (users, todos)

### API Design
- Follow RESTful API conventions
- Use proper HTTP status codes (200, 201, 400, 401, 403, 404, 422, 500)
- Implement proper error handling with meaningful error messages
- Use Pydantic models for all request/response validation
- Version APIs when breaking changes occur (v1/, v2/, etc.)
- Always include pagination for list endpoints

## Authentication & Security

### User Authentication
- Use JWT tokens for authentication
- Implement proper password hashing with bcrypt/passlib
- Include refresh token mechanism
- Set appropriate token expiration times
- Always validate JWT tokens on protected endpoints
- Use proper CORS configuration
- Never expose sensitive data in API responses

### Authorization
- Implement role-based access control (RBAC) when needed
- Use dependency injection for auth requirements
- Validate user permissions at the service layer, not just router level

## Code Quality & Standards

### Python Code Style
- Follow PEP 8 conventions
- Use type hints for all function parameters and return values
- Use Pydantic models for data validation instead of plain dictionaries
- Implement proper async/await patterns throughout
- Use dependency injection for database connections and auth
- Keep functions small and focused (max 20-30 lines)
- Use descriptive variable and function names

### Error Handling
- Always use FastAPI's HTTPException for API errors
- Implement proper logging configuration
- Never expose internal error details in production
- Use structured error responses with consistent format
- Handle database connection errors gracefully

### Testing Standards
- Maintain at least 80% test coverage
- Write unit tests for all service functions
- Include integration tests for API endpoints
- Use pytest fixtures for test data setup
- Test both success and failure scenarios
- Mock external dependencies in unit tests
- Use factories for test data generation when needed

## Performance & Optimization

### Database Performance
- Use database indexes on frequently queried columns
- Implement proper database query optimization
- Use select_related() and prefetch_related() for related data
- Avoid N+1 query problems
- Use database connection pooling
- Implement query result caching where appropriate

### API Performance
- Use async/await throughout the application
- Implement proper response caching headers
- Use FastAPI's background tasks for non-critical operations
- Monitor and log performance metrics
- Implement rate limiting for public endpoints

## Development Workflow

### Code Changes
- Always write tests before implementing features (TDD)
- Run linting and type checking before commits
- Use meaningful commit messages following conventional commits
- Keep commits focused and atomic
- Never commit secrets or credentials

### Environment Management
- Use python-dotenv for environment configuration
- Separate development, staging, and production configurations
- Use environment variables for all sensitive configuration
- Document all required environment variables in README
- Use Docker for consistent development environments

### Documentation
- Document all public API endpoints
- Include usage examples in docstrings
- Keep README.md updated with setup instructions
- Document database schema changes
- Use FastAPI's automatic OpenAPI documentation

## Security Best Practices

### Data Protection
- Never log sensitive data (passwords, tokens, personal info)
- Implement input validation and sanitization
- Use parameterized queries to prevent SQL injection
- Implement CSRF protection for state-changing operations
- Use HTTPS in production environments

### Authentication Security
- Store passwords hashed with salt
- Implement account lockout after failed login attempts
- Use secure session management
- Implement proper token revocation
- Regular security dependency updates

## Monitoring & Logging

### Application Monitoring
- Implement structured logging with appropriate log levels
- Include request IDs for request tracing
- Monitor application performance and errors
- Set up health check endpoints
- Use appropriate alerting for production issues

### Database Monitoring
- Monitor database performance and slow queries
- Set up database backup strategies
- Monitor database connection pool health
- Track database migration status

## Deployment & DevOps

### Application Deployment
- Use containerization (Docker) for consistent deployments
- Implement proper health checks and readiness probes
- Use environment-specific configuration management
- Implement zero-downtime deployment strategies
- Set up proper monitoring and alerting

### Database Management
- Use database migrations for all schema changes
- Implement database backup and recovery procedures
- Monitor database performance metrics
- Use read replicas for read-heavy workloads if needed

## Code Review Guidelines

### Review Checklist
- [ ] Code follows established patterns and conventions
- [ ] Proper error handling and validation
- [ ] Security considerations addressed
- [ ] Tests written and passing
- [ ] Performance implications considered
- [ ] Documentation updated if needed
- [ ] Database migrations included if applicable
- [ ] No hardcoded secrets or credentials

### Review Process
- All code changes must be reviewed before merging
- Use constructive feedback and suggestions
- Focus on code quality, security, and maintainability
- Ensure tests cover the changes appropriately
- Verify backward compatibility when applicable

## Scaling & Evolution Guidelines

### Adding New Features

#### Feature Planning
- Always start with feature design documents outlining scope, requirements, and impact
- Create feature branches with clear naming convention: `feature/feature-name`
- Plan database schema changes before code implementation
- Consider backward compatibility when designing new endpoints
- Document API changes and migration paths

#### New Module Guidelines
- Follow the established layered architecture for all new features
- Create corresponding test modules alongside feature modules
- Add feature-specific routers under `app/routers/`
- Organize related schemas in feature-specific folders if needed
- Update API documentation and OpenAPI specs

#### Database Schema Evolution
- Always use Alembic migrations for schema changes
- Test migrations on development data before production
- Consider data migration scripts for complex schema changes
- Maintain migration rollback capabilities
- Document breaking schema changes with version notes

### Changing Requirements

#### Requirement Documentation
- Maintain a CHANGELOG.md file for all significant changes
- Document architectural decisions in ADRs (Architecture Decision Records)
- Keep requirements traceable to business objectives
- Version control all requirement documents
- Regular requirement reviews and stakeholder validation

#### Breaking Changes Protocol
- Announce breaking changes well in advance
- Provide clear migration guides for deprecated features
- Implement feature flags for gradual rollouts
- Maintain backward compatibility periods when possible
- Use semantic versioning (MAJOR.MINOR.PATCH) for releases

### Performance Scaling

#### Horizontal Scaling
- Design APIs to be stateless for horizontal scaling
- Plan for database read/write separation
- Implement caching strategies at multiple levels
- Use connection pooling for database connections
- Monitor and optimize query performance proactively

#### Monitoring Growth
- Set up performance baselines and alerts
- Monitor memory usage, response times, and throughput
- Track database query performance and slow queries
- Implement health checks and circuit breakers
- Plan capacity growth based on usage patterns

### Security Evolution

#### Security Reviews
- Conduct regular security audits of new features
- Review authentication and authorization changes
- Implement security scanning in CI/CD pipeline
- Regular dependency vulnerability assessments
- Document security incidents and responses

#### Compliance Considerations
- Maintain data privacy compliance (GDPR, CCPA, etc.)
- Document data handling procedures
- Implement audit logging for sensitive operations
- Regular security training and updates
- Plan for compliance changes and new regulations

### Team Scaling

#### Code Ownership
- Define clear module ownership and responsibilities
- Implement code review assignments based on expertise
- Document architectural decisions and patterns
- Create knowledge sharing sessions for complex features
- Maintain coding standards and style guides

#### Communication Standards
- Regular architectural reviews and updates
- Document new patterns and best practices
- Create onboarding documentation for new team members
- Implement pair programming for complex features
- Maintain updated project documentation

### Technology Evolution

#### Dependency Management
- Regular dependency updates and security patches
- Evaluate new frameworks and libraries carefully
- Maintain compatibility testing for major upgrades
- Document technology stack decisions and rationale
- Plan for end-of-life technology replacements

#### Platform Evolution
- Design for cloud-native deployment patterns
- Implement infrastructure as code (IaC)
- Plan for container orchestration and microservices
- Consider service mesh architecture for complex systems
- Document deployment and operational procedures

### Quality Maintenance

#### Testing Strategy Evolution
- Maintain test coverage above 80% as project grows
- Implement integration test suites for new features
- Add performance and load testing for critical paths
- Automate security testing and vulnerability scanning
- Document testing strategies and best practices

#### Documentation Standards
- Maintain API documentation for all changes
- Keep README and setup instructions current
- Document operational procedures and troubleshooting
- Maintain code comments and inline documentation
- Create architecture diagrams and system documentation 